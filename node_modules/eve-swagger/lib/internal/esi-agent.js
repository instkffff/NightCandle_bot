'use strict';

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Agent = require('superagent');
var Bottleneck = require('bottleneck');
var Cache = require('node-cache');
var Moment = require('moment');
var Promise = require('bluebird');
var VError = require('verror');

var CLIENT_ERROR = 'esi:ClientError';
var FORBIDDEN_ERROR = 'esi:ForbiddenError';
var NOT_FOUND_ERROR = 'esi:NotFoundError';
var INTERNAL_SERVER_ERROR = 'esi:InternalServerError';
var GENERIC_ERROR = 'esi:Error';

// Note that this does not call encodeURIComponent, since this string may be
// included in a url (which needs it), or passed to superagent, which takes
// care of the encoding.
function toPathString(value) {
  if (value === undefined || value == null) {
    return '';
  } else if (value instanceof Date) {
    return value.toISOString();
  } else if (value instanceof Array) {
    // All arrays used in path elements are CSV formatted for ESI
    return value.join(',');
  } else {
    return value.toString();
  }
}

function getExpirationTime(response) {
  if (response && response.header && response.header['expires']) {
    var expires = Moment.utc(response.header['expires'], 'ddd, DD MMM YYYY HH:mm:ss GMT');
    return expires.diff(Moment.utc([]), 'seconds', true);
  } else {
    // Default to 5 minutes
    return 300;
  }
}

function getExceptionFromAgentError(error, fullURL) {
  var exception = void 0;
  if (error.response) {
    var type = GENERIC_ERROR;
    if (error.status == 404) {
      type = NOT_FOUND_ERROR;
    } else if (error.status == 403 || error.status == 401) {
      type = FORBIDDEN_ERROR;
    } else if (error.statusType == 4) {
      type = CLIENT_ERROR;
    } else if (error.statusType == 5) {
      type = INTERNAL_SERVER_ERROR;
    }

    exception = new VError({
      name: type,
      cause: error.response.error
    }, 'Error from ESI service for %s: %s', fullURL, error.response.text);
  } else {
    // Some error contacting the service, like a timeout, etc.
    exception = new VError({
      name: GENERIC_ERROR,
      cause: error
    }, 'Error contacting ESI service for %s', fullURL);
  }

  return exception;
}

var ESIRequestHandler = function () {
  function ESIRequestHandler(agent) {
    var token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    (0, _classCallCheck3.default)(this, ESIRequestHandler);

    this._agent = agent;
    this._token = token;
    this._requestCache = new Cache({
      useClones: false,
      stdTTL: 300
    });
  }

  (0, _createClass3.default)(ESIRequestHandler, [{
    key: '_buildURL',
    value: function _buildURL(url, pathParams) {
      var fullURL = this._agent._eveURL;
      if (url.length == 0 || url[0] != '/') {
        fullURL += '/';
      }

      fullURL += url;

      return fullURL.replace(/\{([\w-]+)}/g, function (match, key) {
        if (pathParams && pathParams.hasOwnProperty(key)) {
          // Path parameter is provided
          return encodeURIComponent(toPathString(pathParams[key]));
        } else {
          throw new VError({ name: CLIENT_ERROR }, 'Required path parameter %s is not assigned', key);
        }
      });
    }
  }, {
    key: '_buildQueryParams',
    value: function _buildQueryParams(params) {
      var allParams = (0, _assign2.default)({}, this._agent._defaultOpts);

      if (params) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(params)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var p = _step.value;

            // This converts everything to strings, including arrays to CSV list
            if (params[p] != null) {
              allParams[p] = toPathString(params[p]);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return allParams;
    }
  }, {
    key: '_schedule',
    value: function _schedule(method, url, pathParams, queryParams, body) {
      var _this = this;

      return Promise.try(function () {
        var fullURL = _this._buildURL(url, pathParams);

        // Use stringify on query params and body to get a key specific to the
        // request arguments. Don't bother including default query params since
        // all requests will have those.
        var key = method + ' ' + fullURL + '/' + (0, _stringify2.default)(queryParams) + '+' + (0, _stringify2.default)(body);

        var cached = _this._requestCache.get(key);
        if (cached) {
          // A successful request (non-Promise value) or a pending Promise
          return cached;
        } else {
          // Must make a new request
          var pending = _this._agent._limiter.schedule(function () {
            return _this._request(method, fullURL, queryParams, body);
          }).then(function (response) {
            // Extract the response body and expiration for cache control
            var expires = getExpirationTime(response);
            var data = response.body || {};
            _this._requestCache.set(key, data, expires);
            return data;
          }).catch(function (error) {
            if (!(error instanceof VError)) {
              // Throw consistent exception types
              error = new VError({
                name: GENERIC_ERROR,
                cause: error
              });
            }

            // And make sure to clear out the cache
            _this._requestCache.del(key);
            throw error;
          });

          // Save into cache without any expiration so it exists until
          // the request completes or times out
          _this._requestCache.set(key, pending, 0);

          return pending;
        }
      });
    }
  }, {
    key: '_request',
    value: function _request(method, url, query, body) {
      var _this2 = this;

      return Promise.try(function () {
        // Must make a request via superagent
        var request = Agent(method, url);
        request.type('application/json').accept('application/json');
        request.query(_this2._buildQueryParams(query));
        if (body != null) {
          request.send(body);
        }

        // Handle OAuth SSO
        if (_this2._token != '') {
          request.set({ 'Authorization': 'Bearer ' + _this2._token });
        }
        // User-Agent (but use X-User-Agent (which CCP accepts) so it works in
        // browsers)
        request.set('X-User-Agent', _this2._agent._userAgent);
        // Timeout
        request.timeout(_this2._agent._timeout);

        return new Promise(function (resolve, reject) {
          request.end(function (error, response) {
            if (error) {
              // Errors caught here are response errors from agent, so remap them
              // to a cleaner VError.
              reject(getExceptionFromAgentError(error, url));
            } else {
              resolve(response);
            }
          });
        });
      });
    }
  }, {
    key: 'get',
    value: function get(url) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$path = _ref.path,
          path = _ref$path === undefined ? null : _ref$path,
          _ref$query = _ref.query,
          query = _ref$query === undefined ? null : _ref$query;

      return this._schedule('GET', url, path, query, null);
    }
  }, {
    key: 'put',
    value: function put(url) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$path = _ref2.path,
          path = _ref2$path === undefined ? null : _ref2$path,
          _ref2$query = _ref2.query,
          query = _ref2$query === undefined ? null : _ref2$query,
          _ref2$body = _ref2.body,
          body = _ref2$body === undefined ? null : _ref2$body;

      return this._schedule('PUT', url, path, query, body);
    }
  }, {
    key: 'post',
    value: function post(url) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$path = _ref3.path,
          path = _ref3$path === undefined ? null : _ref3$path,
          _ref3$query = _ref3.query,
          query = _ref3$query === undefined ? null : _ref3$query,
          _ref3$body = _ref3.body,
          body = _ref3$body === undefined ? null : _ref3$body;

      return this._schedule('POST', url, path, query, body);
    }
  }, {
    key: 'del',
    value: function del(url) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref4$path = _ref4.path,
          path = _ref4$path === undefined ? null : _ref4$path,
          _ref4$query = _ref4.query,
          query = _ref4$query === undefined ? null : _ref4$query,
          _ref4$body = _ref4.body,
          body = _ref4$body === undefined ? null : _ref4$body;

      return this._schedule('DELETE', url, path, query, body);
    }
  }]);
  return ESIRequestHandler;
}();

// FIXME add cache options as well (default timeout and disable caching)
// Perhaps we can split it into { service: {url, source, agent, language,
// timeout}, cache: { ... }, rateLimit: { } }


var ESIAgent = function () {
  /**
   * Create a new ESIAgent with the given configuration provided in a single
   * object map. If no argument is provided, the defaults are used.
   *
   * @param service {String} URL to the ESI service
   * @param source {String} Data source used
   * @param agent {String} Custom user agent string to send with each request
   * @param language {String} Language character code
   * @param timeout {Number} Request timeout in milliseconds
   * @param maxConcurrent {Number} Maximum number of requests running at once
   * @param minTime {Number} Minimum time before launching another request (in
   *     milliseconds)
   * @constructor
   * @private
   */
  function ESIAgent() {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        service = _ref5.service,
        source = _ref5.source,
        agent = _ref5.agent,
        language = _ref5.language,
        timeout = _ref5.timeout,
        maxConcurrent = _ref5.maxConcurrent,
        minTime = _ref5.minTime;

    (0, _classCallCheck3.default)(this, ESIAgent);

    // Save URL, agent, and timeout for later as they configure the ApiClient
    this._eveURL = service;
    this._userAgent = agent;
    this._timeout = timeout;

    this._defaultOpts = {
      'datasource': source,
      'language': language
    };

    this._limiter = new Bottleneck(maxConcurrent, minTime, -1, Bottleneck.strategy.LEAK, true);

    // Keyed on access token, returns an ESIRequestHandler instance
    this._handlerCache = new Cache({
      useClones: false,
      stdTTL: 300
    });
    this._noAuthHandler = new ESIRequestHandler(this);
  }

  (0, _createClass3.default)(ESIAgent, [{
    key: 'auth',
    value: function auth(token) {
      var handler = this._handlerCache.get(token);
      if (!handler) {
        handler = new ESIRequestHandler(this, token);
        this._handlerCache.set(token, handler);
      }
      return handler;
    }
  }, {
    key: 'noAuth',
    get: function get() {
      return this._noAuthHandler;
    }
  }]);
  return ESIAgent;
}();

module.exports = ESIAgent;