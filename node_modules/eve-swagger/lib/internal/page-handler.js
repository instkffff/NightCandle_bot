"use strict";

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A utility class to fetch all pages of a resource where pagination is
 * represented by ordinal page numbers.
 * @private
 */
var PageHandler = function () {
  /**
   * Create a PageHandler that fetches partial results using `fetch`, which
   * must be a function that takes a page number and returns a Promise
   * that resolves to an array.
   *
   * If known, `resultLength` can be provided to make it easier to detect when
   * the end of results has been detected.
   *
   * @param fetch {Function} Return a page of results as Promised array; takes
   *    the page number to fetch.
   * @param resultLength {Number} Maximum number of elements in a result, if
   *    a response has fewer than this then continued fetching is ended
   */
  function PageHandler(fetch) {
    var resultLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck3.default)(this, PageHandler);

    this._fetch = fetch;
    this._resultLength = resultLength;
  }

  /**
   * Load all pages for the wrapped resource by repeatedly calling the `fetch`
   * function provided to the handler at creation time. This continues until the
   * result is empty or less than the configured max elements per fetch.
   *
   * @return Promise The promise resolving to an array representing the entire
   *     sequence of data
   */


  (0, _createClass3.default)(PageHandler, [{
    key: "getAll",
    value: function getAll() {
      return this._get(1);
    }
  }, {
    key: "_get",
    value: function _get(page) {
      var _this = this;

      return this._fetch(page).then(function (result) {
        if (result.length < _this._resultLength || result.length == 0) {
          // End of the data so return it
          return result;
        } else {
          // Fetch the next page
          return _this._get(page + 1).then(function (nextResult) {
            // FIXME de-duplicate results if page contents shift between calls
            return result.concat(nextResult);
          });
        }
      });
    }
  }]);
  return PageHandler;
}();

/**
 * A utility class to fetch all pages of a resource where pagination is
 * represented by an optional maximum id that delimits what is returned in each
 * request.
 * @private
 */


var MaxIdHandler = function () {
  /**
   * Create a MaxIdHandler that fetches partial results using `fetch`, which
   * must be a function that takes an optional maximum id and returns a Promise
   * that resolves to an array. `resolveId` must be a function that takes an
   * element of the result array and returns its corresponding id.
   *
   * If known, `resultLength` can be provided to make it easier to detect when
   * the end of results has been detected.
   *
   * @param fetch {Function} Return a page of results as Promised array; takes
   *    an maximum id that all results must be less than, or no id to return
   *    the latest results.
   * @param resolveId {Function} Return the id of an element from the results
   * @param resultLength {Number} Maximum number of elements in a result, if
   *    a response has fewer than this then continued fetching is ended
   */
  function MaxIdHandler(fetch, resolveId) {
    var resultLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    (0, _classCallCheck3.default)(this, MaxIdHandler);

    this._fetch = fetch;
    this._resolveId = resolveId;
    this._resultLength = resultLength;
  }

  /**
   * Load all pages for the wrapped resource by repeatedly calling the
   * `fetch` function provided to the handler at creation time. The `resolveId`
   * function is used to extract the id from the last element in the results,
   * which becomes the max id to the next fetch call. This continues until
   * the result is empty or less than the configured max elements per fetch.
   *
   * @return Promise The promise resolving to an array representing the entire
   *     sequence of data
   */


  (0, _createClass3.default)(MaxIdHandler, [{
    key: "getAll",
    value: function getAll() {
      return this._get(undefined);
    }
  }, {
    key: "_get",
    value: function _get(maxId) {
      var _this2 = this;

      return this._fetch(maxId).then(function (result) {
        if (result.length < _this2._resultLength || result.length == 0) {
          // End of the data so just return it
          return result;
        } else {
          // Iterate and fetch again based on the id at the end of the result
          // (assuming that ids are sorted appropriately in the result).
          var nextMaxId = _this2._resolveId(result[result.length - 1]);
          return _this2._get(nextMaxId).then(function (nextResult) {
            // Note: this shouldn't require de-duplication because pagination
            // is based off of ids, and so each call should return mutually
            // exclusive sets.
            return result.concat(nextResult);
          });
        }
      });
    }
  }]);
  return MaxIdHandler;
}();

module.exports = [PageHandler, MaxIdHandler];